Αγαπητέ Εξεταστή,


ΚΛΑΣΕΙΣ
-------
vector_info: Αναπάρσταση διανύσματος. Περιέχει id (δικό μας), id αρχείου και τις
             συντεταγμένες του.

hash_node  : Κόμβος των buckets. Περιέχει id και g του διανύσματος.

bucket     : Περιέχει έναν vector από buclets.

trueNN_node: Πραγματικός κοντινότερος γείτονας. Περιέχει id, την απόσταση από
             τον κοντινότερο γείτονα και τον χρόνο που χρειάστηκε για να τον βρει.

LSH_neig   : Γείτονας μέσω LSH. Περιέχει id, την απόσταση από του γείτονα και
             τον χρόνο που χρειάστηκε για να τον βρει.


ΥΛΟΠΟΙΗΣΗ
---------
Διαβάζουμε τα input/query files και αποθηκεύουμε τα διανύσματα σε vector. Μετά
αποθηκεύουμε τα διανύσματα s που θα χρειαστούμε για όλους τους hashtables.
Υπολογίζουμε όλες τις συναρτήσεις h (input*l*k το πλήθος) και g που χρειαζόμαστε.
Τέλος γεμίζουμε όλους τους l hashtables μέσω όλων των g που έχουμε ήδη αποθηκεύσει.


ΜΕΤΡΗΣΕΙΣ
---------
??

ΠΑΡΑΤΗΡΗΣΕΙΣ
------------
Όταν δεν κάνουμε το range search (bonus), το υπολογίζουμε βρίσκοντας τον μέσο
όρο των ελάχιστων αποστάσεων κάθε query με το datset. Έπειτα θέτουμε w=10*r.
Ως m βάζουμε max{ai}+1.
Παρατηρήσαμε ότι ενώ το Average AF !!(κάπως έτσι)!! κυμαίνεται περίπου στο 1.10,
έχοντας γενικά επιλογές γειτόνων κοντά στις βέλτιστες, το Max AF !!(κάπως έτσι)!!
είναι αρκετά μεγάλο, περίπου 3-4. Άρα σε λίγα queries υπάρχει μεγάλη αστοχία,
πράγμα που αυξάνει και το Average AF. !!(κάπως έτσι)!!
Αν κάνουμε m++ τότε ο αλγόριθμος (σχεδόν σε κάθε μέτρηση) επιστρέφει τον πραγματικό
κοντινότερο γείτονα για κάθε query, αλλά αργεί αρκετά, κάτι που προτιμήσαμε (?).


COMPILE & RUN COMMANDS
----------------------
μπλα μπλα μπλα


Δικοί σου,
(Πρώην) Μαρουλάκι & Μπριζολάκι
